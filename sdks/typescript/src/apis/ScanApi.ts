/* tslint:disable */
/* eslint-disable */
/**
 * Sipher â€” Privacy-as-a-Skill API
 * REST API wrapping SIP Protocol\'s privacy SDK for Solana agents. Stealth addresses, Pedersen commitments, shielded transfers, and viewing key compliance.
 *
 * The version of the OpenAPI document: 0.1.0
 * Contact: hello@sip-protocol.org
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import type {
  GetHealth503Response,
  ScanAssets200Response,
  ScanAssetsRequest,
  ScanPayments200Response,
  ScanPaymentsBatch200Response,
  ScanPaymentsBatchRequest,
  ScanPaymentsRequest,
} from '../models/index';
import {
    GetHealth503ResponseFromJSON,
    GetHealth503ResponseToJSON,
    ScanAssets200ResponseFromJSON,
    ScanAssets200ResponseToJSON,
    ScanAssetsRequestFromJSON,
    ScanAssetsRequestToJSON,
    ScanPayments200ResponseFromJSON,
    ScanPayments200ResponseToJSON,
    ScanPaymentsBatch200ResponseFromJSON,
    ScanPaymentsBatch200ResponseToJSON,
    ScanPaymentsBatchRequestFromJSON,
    ScanPaymentsBatchRequestToJSON,
    ScanPaymentsRequestFromJSON,
    ScanPaymentsRequestToJSON,
} from '../models/index';

export interface ScanAssetsOperationRequest {
    scanAssetsRequest: ScanAssetsRequest;
}

export interface ScanPaymentsOperationRequest {
    scanPaymentsRequest: ScanPaymentsRequest;
}

export interface ScanPaymentsBatchOperationRequest {
    scanPaymentsBatchRequest: ScanPaymentsBatchRequest;
}

/**
 * ScanApi - interface
 * 
 * @export
 * @interface ScanApiInterface
 */
export interface ScanApiInterface {
    /**
     * Query all assets (SPL tokens, NFTs, cNFTs) at a stealth address using Helius DAS getAssetsByOwner API. Falls back to standard getTokenAccountsByOwner if Helius is not configured.
     * @summary Scan stealth address assets via Helius DAS
     * @param {ScanAssetsRequest} scanAssetsRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ScanApiInterface
     */
    scanAssetsRaw(requestParameters: ScanAssetsOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ScanAssets200Response>>;

    /**
     * Query all assets (SPL tokens, NFTs, cNFTs) at a stealth address using Helius DAS getAssetsByOwner API. Falls back to standard getTokenAccountsByOwner if Helius is not configured.
     * Scan stealth address assets via Helius DAS
     */
    scanAssets(scanAssetsRequest: ScanAssetsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ScanAssets200Response>;

    /**
     * Scans Solana for SIP announcements matching the provided viewing key.
     * @summary Scan for incoming shielded payments
     * @param {ScanPaymentsRequest} scanPaymentsRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ScanApiInterface
     */
    scanPaymentsRaw(requestParameters: ScanPaymentsOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ScanPayments200Response>>;

    /**
     * Scans Solana for SIP announcements matching the provided viewing key.
     * Scan for incoming shielded payments
     */
    scanPayments(scanPaymentsRequest: ScanPaymentsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ScanPayments200Response>;

    /**
     * Scan for incoming shielded payments across multiple viewing key pairs. Max 100 key pairs per request.
     * @summary Batch scan for payments across multiple key pairs
     * @param {ScanPaymentsBatchRequest} scanPaymentsBatchRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ScanApiInterface
     */
    scanPaymentsBatchRaw(requestParameters: ScanPaymentsBatchOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ScanPaymentsBatch200Response>>;

    /**
     * Scan for incoming shielded payments across multiple viewing key pairs. Max 100 key pairs per request.
     * Batch scan for payments across multiple key pairs
     */
    scanPaymentsBatch(scanPaymentsBatchRequest: ScanPaymentsBatchRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ScanPaymentsBatch200Response>;

}

/**
 * 
 */
export class ScanApi extends runtime.BaseAPI implements ScanApiInterface {

    /**
     * Query all assets (SPL tokens, NFTs, cNFTs) at a stealth address using Helius DAS getAssetsByOwner API. Falls back to standard getTokenAccountsByOwner if Helius is not configured.
     * Scan stealth address assets via Helius DAS
     */
    async scanAssetsRaw(requestParameters: ScanAssetsOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ScanAssets200Response>> {
        if (requestParameters['scanAssetsRequest'] == null) {
            throw new runtime.RequiredError(
                'scanAssetsRequest',
                'Required parameter "scanAssetsRequest" was null or undefined when calling scanAssets().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-API-Key"] = await this.configuration.apiKey("X-API-Key"); // ApiKeyAuth authentication
        }


        let urlPath = `/v1/scan/assets`;

        const response = await this.request({
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: ScanAssetsRequestToJSON(requestParameters['scanAssetsRequest']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ScanAssets200ResponseFromJSON(jsonValue));
    }

    /**
     * Query all assets (SPL tokens, NFTs, cNFTs) at a stealth address using Helius DAS getAssetsByOwner API. Falls back to standard getTokenAccountsByOwner if Helius is not configured.
     * Scan stealth address assets via Helius DAS
     */
    async scanAssets(scanAssetsRequest: ScanAssetsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ScanAssets200Response> {
        const response = await this.scanAssetsRaw({ scanAssetsRequest: scanAssetsRequest }, initOverrides);
        return await response.value();
    }

    /**
     * Scans Solana for SIP announcements matching the provided viewing key.
     * Scan for incoming shielded payments
     */
    async scanPaymentsRaw(requestParameters: ScanPaymentsOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ScanPayments200Response>> {
        if (requestParameters['scanPaymentsRequest'] == null) {
            throw new runtime.RequiredError(
                'scanPaymentsRequest',
                'Required parameter "scanPaymentsRequest" was null or undefined when calling scanPayments().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-API-Key"] = await this.configuration.apiKey("X-API-Key"); // ApiKeyAuth authentication
        }


        let urlPath = `/v1/scan/payments`;

        const response = await this.request({
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: ScanPaymentsRequestToJSON(requestParameters['scanPaymentsRequest']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ScanPayments200ResponseFromJSON(jsonValue));
    }

    /**
     * Scans Solana for SIP announcements matching the provided viewing key.
     * Scan for incoming shielded payments
     */
    async scanPayments(scanPaymentsRequest: ScanPaymentsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ScanPayments200Response> {
        const response = await this.scanPaymentsRaw({ scanPaymentsRequest: scanPaymentsRequest }, initOverrides);
        return await response.value();
    }

    /**
     * Scan for incoming shielded payments across multiple viewing key pairs. Max 100 key pairs per request.
     * Batch scan for payments across multiple key pairs
     */
    async scanPaymentsBatchRaw(requestParameters: ScanPaymentsBatchOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ScanPaymentsBatch200Response>> {
        if (requestParameters['scanPaymentsBatchRequest'] == null) {
            throw new runtime.RequiredError(
                'scanPaymentsBatchRequest',
                'Required parameter "scanPaymentsBatchRequest" was null or undefined when calling scanPaymentsBatch().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-API-Key"] = await this.configuration.apiKey("X-API-Key"); // ApiKeyAuth authentication
        }


        let urlPath = `/v1/scan/payments/batch`;

        const response = await this.request({
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: ScanPaymentsBatchRequestToJSON(requestParameters['scanPaymentsBatchRequest']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ScanPaymentsBatch200ResponseFromJSON(jsonValue));
    }

    /**
     * Scan for incoming shielded payments across multiple viewing key pairs. Max 100 key pairs per request.
     * Batch scan for payments across multiple key pairs
     */
    async scanPaymentsBatch(scanPaymentsBatchRequest: ScanPaymentsBatchRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ScanPaymentsBatch200Response> {
        const response = await this.scanPaymentsBatchRaw({ scanPaymentsBatchRequest: scanPaymentsBatchRequest }, initOverrides);
        return await response.value();
    }

}
