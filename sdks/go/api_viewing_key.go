/*
Sipher â€” Privacy-as-a-Skill API

REST API wrapping SIP Protocol's privacy SDK for Solana agents. Stealth addresses, Pedersen commitments, shielded transfers, and viewing key compliance.

API version: 0.1.0
Contact: hello@sip-protocol.org
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package sipher

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
)


// ViewingKeyAPIService ViewingKeyAPI service
type ViewingKeyAPIService service

type ApiViewingKeyDecryptRequest struct {
	ctx context.Context
	ApiService *ViewingKeyAPIService
	viewingKeyDecryptRequest *ViewingKeyDecryptRequest
}

func (r ApiViewingKeyDecryptRequest) ViewingKeyDecryptRequest(viewingKeyDecryptRequest ViewingKeyDecryptRequest) ApiViewingKeyDecryptRequest {
	r.viewingKeyDecryptRequest = &viewingKeyDecryptRequest
	return r
}

func (r ApiViewingKeyDecryptRequest) Execute() (*ViewingKeyDecrypt200Response, *http.Response, error) {
	return r.ApiService.ViewingKeyDecryptExecute(r)
}

/*
ViewingKeyDecrypt Decrypt transaction with viewing key

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiViewingKeyDecryptRequest
*/
func (a *ViewingKeyAPIService) ViewingKeyDecrypt(ctx context.Context) ApiViewingKeyDecryptRequest {
	return ApiViewingKeyDecryptRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ViewingKeyDecrypt200Response
func (a *ViewingKeyAPIService) ViewingKeyDecryptExecute(r ApiViewingKeyDecryptRequest) (*ViewingKeyDecrypt200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ViewingKeyDecrypt200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ViewingKeyAPIService.ViewingKeyDecrypt")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/viewing-key/decrypt"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.viewingKeyDecryptRequest == nil {
		return localVarReturnValue, nil, reportError("viewingKeyDecryptRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.viewingKeyDecryptRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v GetHealth503Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v GetHealth503Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiViewingKeyDeriveRequest struct {
	ctx context.Context
	ApiService *ViewingKeyAPIService
	viewingKeyDeriveRequest *ViewingKeyDeriveRequest
}

func (r ApiViewingKeyDeriveRequest) ViewingKeyDeriveRequest(viewingKeyDeriveRequest ViewingKeyDeriveRequest) ApiViewingKeyDeriveRequest {
	r.viewingKeyDeriveRequest = &viewingKeyDeriveRequest
	return r
}

func (r ApiViewingKeyDeriveRequest) Execute() (*ViewingKeyDerive200Response, *http.Response, error) {
	return r.ApiService.ViewingKeyDeriveExecute(r)
}

/*
ViewingKeyDerive Derive child viewing key (BIP32-style)

Derives a child viewing key from a master key using HMAC-SHA512. Supports hierarchical key trees for scoped compliance access (per-auditor, per-timeframe).

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiViewingKeyDeriveRequest
*/
func (a *ViewingKeyAPIService) ViewingKeyDerive(ctx context.Context) ApiViewingKeyDeriveRequest {
	return ApiViewingKeyDeriveRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ViewingKeyDerive200Response
func (a *ViewingKeyAPIService) ViewingKeyDeriveExecute(r ApiViewingKeyDeriveRequest) (*ViewingKeyDerive200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ViewingKeyDerive200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ViewingKeyAPIService.ViewingKeyDerive")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/viewing-key/derive"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.viewingKeyDeriveRequest == nil {
		return localVarReturnValue, nil, reportError("viewingKeyDeriveRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.viewingKeyDeriveRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v GetHealth503Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiViewingKeyDiscloseRequest struct {
	ctx context.Context
	ApiService *ViewingKeyAPIService
	viewingKeyDiscloseRequest *ViewingKeyDiscloseRequest
}

func (r ApiViewingKeyDiscloseRequest) ViewingKeyDiscloseRequest(viewingKeyDiscloseRequest ViewingKeyDiscloseRequest) ApiViewingKeyDiscloseRequest {
	r.viewingKeyDiscloseRequest = &viewingKeyDiscloseRequest
	return r
}

func (r ApiViewingKeyDiscloseRequest) Execute() (*ViewingKeyDisclose200Response, *http.Response, error) {
	return r.ApiService.ViewingKeyDiscloseExecute(r)
}

/*
ViewingKeyDisclose Encrypt transaction for disclosure

Encrypts transaction data so only the viewing key holder can decrypt it (selective compliance).

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiViewingKeyDiscloseRequest
*/
func (a *ViewingKeyAPIService) ViewingKeyDisclose(ctx context.Context) ApiViewingKeyDiscloseRequest {
	return ApiViewingKeyDiscloseRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ViewingKeyDisclose200Response
func (a *ViewingKeyAPIService) ViewingKeyDiscloseExecute(r ApiViewingKeyDiscloseRequest) (*ViewingKeyDisclose200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ViewingKeyDisclose200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ViewingKeyAPIService.ViewingKeyDisclose")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/viewing-key/disclose"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.viewingKeyDiscloseRequest == nil {
		return localVarReturnValue, nil, reportError("viewingKeyDiscloseRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.viewingKeyDiscloseRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v GetHealth503Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiViewingKeyGenerateRequest struct {
	ctx context.Context
	ApiService *ViewingKeyAPIService
	viewingKeyGenerateRequest *ViewingKeyGenerateRequest
}

func (r ApiViewingKeyGenerateRequest) ViewingKeyGenerateRequest(viewingKeyGenerateRequest ViewingKeyGenerateRequest) ApiViewingKeyGenerateRequest {
	r.viewingKeyGenerateRequest = &viewingKeyGenerateRequest
	return r
}

func (r ApiViewingKeyGenerateRequest) Execute() (*ViewingKeyGenerate200Response, *http.Response, error) {
	return r.ApiService.ViewingKeyGenerateExecute(r)
}

/*
ViewingKeyGenerate Generate viewing key

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiViewingKeyGenerateRequest
*/
func (a *ViewingKeyAPIService) ViewingKeyGenerate(ctx context.Context) ApiViewingKeyGenerateRequest {
	return ApiViewingKeyGenerateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ViewingKeyGenerate200Response
func (a *ViewingKeyAPIService) ViewingKeyGenerateExecute(r ApiViewingKeyGenerateRequest) (*ViewingKeyGenerate200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ViewingKeyGenerate200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ViewingKeyAPIService.ViewingKeyGenerate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/viewing-key/generate"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.viewingKeyGenerateRequest == nil {
		return localVarReturnValue, nil, reportError("viewingKeyGenerateRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.viewingKeyGenerateRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v GetHealth503Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiViewingKeyVerifyHierarchyRequest struct {
	ctx context.Context
	ApiService *ViewingKeyAPIService
	viewingKeyVerifyHierarchyRequest *ViewingKeyVerifyHierarchyRequest
}

func (r ApiViewingKeyVerifyHierarchyRequest) ViewingKeyVerifyHierarchyRequest(viewingKeyVerifyHierarchyRequest ViewingKeyVerifyHierarchyRequest) ApiViewingKeyVerifyHierarchyRequest {
	r.viewingKeyVerifyHierarchyRequest = &viewingKeyVerifyHierarchyRequest
	return r
}

func (r ApiViewingKeyVerifyHierarchyRequest) Execute() (*ViewingKeyVerifyHierarchy200Response, *http.Response, error) {
	return r.ApiService.ViewingKeyVerifyHierarchyExecute(r)
}

/*
ViewingKeyVerifyHierarchy Verify viewing key parent-child relationship

Verifies that a child viewing key was derived from a specific parent key at a given path.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiViewingKeyVerifyHierarchyRequest
*/
func (a *ViewingKeyAPIService) ViewingKeyVerifyHierarchy(ctx context.Context) ApiViewingKeyVerifyHierarchyRequest {
	return ApiViewingKeyVerifyHierarchyRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ViewingKeyVerifyHierarchy200Response
func (a *ViewingKeyAPIService) ViewingKeyVerifyHierarchyExecute(r ApiViewingKeyVerifyHierarchyRequest) (*ViewingKeyVerifyHierarchy200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ViewingKeyVerifyHierarchy200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ViewingKeyAPIService.ViewingKeyVerifyHierarchy")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/viewing-key/verify-hierarchy"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.viewingKeyVerifyHierarchyRequest == nil {
		return localVarReturnValue, nil, reportError("viewingKeyVerifyHierarchyRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.viewingKeyVerifyHierarchyRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v GetHealth503Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
